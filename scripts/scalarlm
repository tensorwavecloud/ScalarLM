#!/usr/bin/env bash
# This script was generated by bashly 1.2.9 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
scalarlm_usage() {
  printf "scalarlm - ScalarLM CLI\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm COMMAND\n"
  printf "  scalarlm [COMMAND] --help | -h\n"
  printf "  scalarlm --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Build image from dockerfile\n" "build-image"
  printf "  %s   Build image from dockerfile and push to depot\n" "depot-build"
  printf "  %s   Start the container\n" "up         "
  printf "  %s   Run tests in the container\n" "test       "
  printf "  %s   Invoke the LLM tool\n" "llm        "
  printf "  %s   Publish the client package to pypi\n" "pypi       "
  printf "  %s   Run the benchmark tests\n" "benchmark  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
scalarlm_build_image_usage() {
  printf "scalarlm build-image - Build image from dockerfile\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm build-image [TARGET]\n"
  printf "  scalarlm build-image --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TARGET"
    printf "\n"
    printf "    %s\n" "Allowed: cpu, nvidia, arm, amd"
    printf "    %s\n" "Default: cpu"
    echo

  fi
}

# :command.usage
scalarlm_depot_build_usage() {
  printf "scalarlm depot-build - Build image from dockerfile and push to depot\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm depot-build [TARGET]\n"
  printf "  scalarlm depot-build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TARGET"
    printf "\n"
    printf "    %s\n" "Allowed: cpu, nvidia, arm, amd"
    printf "    %s\n" "Default: cpu"
    echo

  fi
}

# :command.usage
scalarlm_up_usage() {
  printf "scalarlm up - Start the container\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm up [TARGET]\n"
  printf "  scalarlm up --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TARGET"
    printf "\n"
    printf "    %s\n" "Allowed: cpu, nvidia, amd"
    printf "    %s\n" "Default: cpu"
    echo

  fi
}

# :command.usage
scalarlm_test_usage() {
  printf "scalarlm test - Run tests in the container\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm test [TEST-PATH] [OPTIONS]\n"
  printf "  scalarlm test --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--coverage-path COVERAGE-PATH"
    printf "    Absolute path to a directory to write coverage results into\n"
    printf "    %s\n" "Default: /tmp/cray/coverage"
    echo

    # :flag.usage
    printf "  %s\n" "--verbose VERBOSE"
    printf "    Prints out DEBUG logs as the test is running.\n"
    printf "    %s\n" "Allowed: yes, no"
    printf "    %s\n" "Default: no"
    echo

    # :flag.usage
    printf "  %s\n" "--workers WORKERS"
    printf "    Number of workers, default is auto\n"
    printf "    %s\n" "Default: auto"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TEST-PATH"
    printf "    Relative path to the directory or file with test cases\n"
    printf "    %s\n" "Default: test/infra/*"
    echo

  fi
}

# :command.usage
scalarlm_llm_usage() {
  printf "scalarlm llm - Invoke the LLM tool\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm llm COMMAND\n"
  printf "  scalarlm llm [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Plot the LLM data\n" "plot  "
  printf "  %s   Get the logs for the LLM model\n" "logs  "
  printf "  %s   List all the LLM models\n" "ls    "
  printf "  %s   Invoke the squeue tool from SLURM\n" "squeue"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
scalarlm_llm_plot_usage() {
  printf "scalarlm llm plot - Plot the LLM data\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm llm plot [MODEL]\n"
  printf "  scalarlm llm plot --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Model name to plot\n"
    echo

  fi
}

# :command.usage
scalarlm_llm_logs_usage() {
  printf "scalarlm llm logs - Get the logs for the LLM model\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm llm logs [MODEL] [OPTIONS]\n"
  printf "  scalarlm llm logs --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tail, -t"
    printf "    Whether to tail the logs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--follow, -f"
    printf "    Whether to follow the logs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--lines, -l LINES"
    printf "    Number of lines to show\n"
    printf "    %s\n" "Default: 100"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Model name to get logs for\n"
    echo

  fi
}

# :command.usage
scalarlm_llm_ls_usage() {
  printf "scalarlm llm ls - List all the LLM models\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm llm ls\n"
  printf "  scalarlm llm ls --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
scalarlm_llm_squeue_usage() {
  printf "scalarlm llm squeue - Invoke the squeue tool from SLURM\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm llm squeue\n"
  printf "  scalarlm llm squeue --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
scalarlm_pypi_usage() {
  printf "scalarlm pypi - Publish the client package to pypi\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm pypi\n"
  printf "  scalarlm pypi --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
scalarlm_benchmark_usage() {
  printf "scalarlm benchmark - Run the benchmark tests\n\n"

  printf "%s\n" "Usage:"
  printf "  scalarlm benchmark [TARGET] [VISIBLE-GPUS]\n"
  printf "  scalarlm benchmark --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TARGET"
    printf "\n"
    printf "    %s\n" "Allowed: cpu, nvidia, arm, amd"
    printf "    %s\n" "Default: cpu"
    echo

    # :argument.usage
    printf "  %s\n" "VISIBLE-GPUS"
    printf "    Comma separated list of the IDs of visible gpus\n"
    printf "    %s\n" "Default: 0"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# cmd/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# :command.command_functions
# :command.function
scalarlm_build_image_command() {

  # cmd/build_image_command.sh
  inspect_args

  target=${args[target]}

  declare -a vllm_target_device
  declare -a docker_platform

  # If target is cpu, build the image with the cpu base image
  if [ "$target" == "cpu" ]; then
      vllm_target_device=("cpu")
      if [ "$(uname -m)" == "x86_64" ]; then
          docker_platform=("linux/amd64")
      else
          docker_platform=("linux/arm64/v8")
      fi
  elif [ "$target" == "amd" ]; then
      vllm_target_device=("rocm")
      docker_platform=("linux/amd64")
  else
      vllm_target_device=("cuda")
      docker_platform=("linux/amd64")
  fi

  docker_build_command="docker build --platform ${docker_platform} --build-arg BASE_NAME=${target} --build-arg VLLM_TARGET_DEVICE=${vllm_target_device} -t cray:latest --shm-size=8g ."

  # Run docker build command
  echo $(green_bold Building image with command: ${docker_build_command})
  eval $docker_build_command

  echo $(green_bold Successfully built image)

}

# :command.function
scalarlm_depot_build_command() {

  # cmd/depot_build_command.sh
  inspect_args

  target=${args[target]}

  declare -a vllm_target_device
  declare -a docker_platform

  # If target is cpu, build the image with the cpu base image
  if [ "$target" == "cpu" ]; then
      vllm_target_device=("cpu")
      docker_platform=("linux/amd64")
  elif [ "$target" == "arm" ]; then
      vllm_target_device=("cpu")
      docker_platform=("linux/arm64/v8")
  elif [ "$target" == "amd" ]; then
      vllm_target_device=("rocm")
      docker_platform=("linux/amd64")
  else
      vllm_target_device=("cuda")
      docker_platform=("linux/amd64")
  fi

  docker_build_command="depot build --platform ${docker_platform} --build-arg BASE_NAME=${target} --build-arg VLLM_TARGET_DEVICE=${vllm_target_device} -t gdiamos/cray-${target}:latest --push ."

  # Run docker build command
  echo $(green_bold Building image with command: ${docker_build_command})
  eval $docker_build_command

  echo $(green_bold Successfully built image)

}

# :command.function
scalarlm_up_command() {

  # cmd/up_command.sh
  inspect_args

  target=${args[target]}

  declare -a vllm_target_device
  declare -a docker_compose_service

  if [ "$target" == "cpu" ]; then
      vllm_target_device=("cpu")
      docker_compose_service="cray"
  elif [ "$target" == "amd" ]; then
      vllm_target_device=("rocm")
      docker_compose_service="cray-amd"
  else
      vllm_target_device=("cuda")
      docker_compose_service="cray-nvidia"
  fi

  BASE_NAME=${target} VLLM_TARGET_DEVICE=${vllm_target_device} docker compose -f docker-compose.yaml up ${docker_compose_service} --build --force-recreate

}

# :command.function
scalarlm_test_command() {

  # cmd/test_command.sh
  inspect_args

  test_path=${args[test-path]}
  tag=${args[--tag]}
  verbose=${args[--verbose]}
  workers=${args[--workers]}

  if [ -z "$tag" ]; then
    tag="cray:latest"
  fi

  ./cray build-image

  declare -a start_slurm_command_parts

  start_slurm_command_parts=(
      "./scripts/start_slurm.sh" ";"
  )

  declare -a pytest_command_parts
  pytest_command_parts=(
        "${start_slurm_command_parts[*]}"
        "python" "-m" "pytest" "-rF" "--dist=loadgroup" "--color=yes"
        "--durations=10" "--durations-min=10.0" "--forked" "--verbose" "-vv"
        "-o" "log_cli=true" "-o" "log_cli_level=DEBUG")

  if [ "yes" == "$verbose" ]; then
    pytest_command_parts+=("-rP")
  fi

  pytest_command_parts+=($test_path)
  pytest_command="${pytest_command_parts[*]}"

  TTY=-t
  if test -t 0; then
    TTY=-it
  fi

  echo "Test path: $test_path"
  echo $command
  echo $tag

  # Remove the trailing * from the test path, if it exists
  base_test_path=${test_path%\*}

  if [ ! -e $base_test_path ]; then
    echo $(red_bold "File or does directory exists:  $base_test_path")
    exit 1
  fi

  declare -a docker_command_parts

  docker_command_parts=("docker" "run" "--rm" "--init" )

  docker_command_parts+=("-e" "PY_FORCE_COLOR=1"
              "-e" "PY_COLORS=1"
              "-e" "FORCE_COLOR=1"
              "$TTY" "$tag" "sh" "-c" "'$pytest_command'")

  docker_command="${docker_command_parts[*]}"
  echo $docker_command
  eval $docker_command

}

# :command.function
scalarlm_llm_plot_command() {

  # cmd/llm_plot_command.sh
  inspect_args

  model=${args[model]}

  if [ -z "$model" ]; then
      model="latest"
  fi

  ./cray build-image

  declare -a plot_command_parts
  plot_command_parts=(
        "python" "/app/cray/sdk/masint/cli/main.py" "plot" "--model" "$model"
  )

  plot_command="${plot_command_parts[*]}"

  echo $command

  # Get the directory of this script
  LOCAL_DIRECTORY="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

  # Set cwd to the project root directory
  ROOT_DIRECTORY=$LOCAL_DIRECTORY/..

  declare -a docker_command_parts

  # Make sure the data directory exists
  mkdir -p $ROOT_DIRECTORY/data

  docker_command_parts=("docker" "run" "--rm" "-v" "$ROOT_DIRECTORY/data:/app/cray/data" "--network" "host")

  docker_command_parts+=("cray:latest" "sh" "-c" "'$plot_command'")

  docker_command="${docker_command_parts[*]}"
  echo $docker_command
  eval $docker_command

}

# :command.function
scalarlm_llm_logs_command() {

  # cmd/llm_logs_command.sh
  inspect_args

  model=${args[model]}
  tail=${args[--tail]}
  lines=${args[--lines]}
  follow=${args[--follow]}

  if [ -z "$model" ]; then
      model="latest"
  fi

  ./cray build-image

  declare -a log_command_parts
  log_command_parts=(
        "python" "/app/cray/sdk/masint/cli/main.py" "logs" "--model" "$model" "--lines" "$lines"
  )

  echo $tail

  # If tail exists, add it to the command
  if [ -n "$tail" ]; then
      log_command_parts+=("--tail")
  fi

  # If follow exists, add it to the command
  if [ -n "$follow" ]; then
      log_command_parts+=("--follow")
  fi

  log_command="${log_command_parts[*]}"

  echo $command

  declare -a docker_command_parts

  docker_command_parts=("docker" "run" "-it" "--rm" "--network" "host")

  docker_command_parts+=("cray:latest" "sh" "-c" "'$log_command'")

  docker_command="${docker_command_parts[*]}"
  echo $docker_command
  eval $docker_command

}

# :command.function
scalarlm_llm_ls_command() {

  # cmd/llm_ls_command.sh
  inspect_args

  ./cray build-image

  declare -a ls_command_parts
  ls_command_parts=(
        "python" "/app/cray/sdk/masint/cli/main.py" "ls"
  )

  ls_command="${ls_command_parts[*]}"

  echo $command

  # Get the directory of this script
  LOCAL_DIRECTORY="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

  # Set cwd to the project root directory
  ROOT_DIRECTORY=$LOCAL_DIRECTORY/..

  declare -a docker_command_parts

  # Make sure the data directory exists
  mkdir -p $ROOT_DIRECTORY/data

  docker_command_parts=("docker" "run" "--rm" "--network" "host")

  docker_command_parts+=("cray:latest" "sh" "-c" "'$ls_command'")

  docker_command="${docker_command_parts[*]}"
  echo $docker_command
  eval $docker_command

}

# :command.function
scalarlm_llm_squeue_command() {

  # cmd/llm_squeue_command.sh
  inspect_args

  ./cray build-image

  declare -a squeue_command_parts
  squeue_command_parts=(
        "python" "/app/cray/sdk/masint/cli/main.py" "squeue"
  )

  squeue_command="${squeue_command_parts[*]}"

  echo $command

  # Get the directory of this script
  LOCAL_DIRECTORY="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

  # Set cwd to the project root directory
  ROOT_DIRECTORY=$LOCAL_DIRECTORY/..

  declare -a docker_command_parts

  # Make sure the data directory exists
  mkdir -p $ROOT_DIRECTORY/data

  docker_command_parts=("docker" "run" "--rm" "--network" "host")

  docker_command_parts+=("cray:latest" "sh" "-c" "'$squeue_command'")

  docker_command="${docker_command_parts[*]}"
  echo $docker_command
  eval $docker_command

}

# :command.function
scalarlm_pypi_command() {

  # cmd/pypi_command.sh
  inspect_args

  # Get the directory of this script
  LOCAL_DIRECTORY="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

  # Set cwd to the project sdk directory
  ROOT_DIRECTORY=$LOCAL_DIRECTORY/../sdk

  cd $ROOT_DIRECTORY

  # Build sdk wheel from sdk/pyproject.toml
  wheel_build_command="python -m build --sdist --wheel --outdir dist/ ."

  # Run sdk wheel build
  echo $(green_bold Building wheel with command: ${wheel_build_command})
  eval $wheel_build_command

  echo $(green_bold Successfully built wheel)

  # Upload wheel to pypi
  pypi_upload_command="twine upload dist/*"

  # Run pypi upload command
  echo $(green_bold Uploading wheel to pypi with command: ${pypi_upload_command})
  eval $pypi_upload_command

  echo $(green_bold Successfully uploaded wheel to pypi)

}

# :command.function
scalarlm_benchmark_command() {

  # cmd/benchmark_command.sh
  inspect_args

  target=${args[target]}
  visible_gpus=${args[visible-gpus]}

  ./scalarlm build-image $target

  declare -a benchmark_command_parts
  benchmark_command_parts=(
        "PYTORCH_TUNABLEOP_ENABLED=1" "PYTORCH_TUNABLEOP_VERBOSE=1" "CUDA_VISIBLE_DEVICES=${visible_gpus}" "python" "/app/cray/test/benchmark/main.py"
  )

  benchmark_command="${benchmark_command_parts[*]}"

  echo $command

  # Get the directory of this script
  LOCAL_DIRECTORY="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

  # Set cwd to the project root directory
  ROOT_DIRECTORY=$LOCAL_DIRECTORY/..

  declare -a docker_command_parts

  # Make sure the data directory exists
  mkdir -p $ROOT_DIRECTORY/data

  docker_command_parts=("docker" "run" "-it" "--rm" "--network" "host" "-v" "$ROOT_DIRECTORY/data:/app/cray/data")

  declare -a gpu_options

  # Set the GPU options depending on the target
  if [ "$target" == "cpu" ]; then
      gpu_options+=()
  elif [ "$target" == "amd" ]; then
      gpu_options+=("--device" "/dev/kfd" "--device" "/dev/dri")
  else
      gpu_options+=("--gpus" "all")
  fi

  docker_command_parts+=("${gpu_options[@]}")
  docker_command_parts+=("cray:latest" "sh" "-c" "'$benchmark_command'")

  docker_command="${docker_command_parts[*]}"
  echo $docker_command
  eval $docker_command

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        scalarlm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    build-image)
      action="build-image"
      shift
      scalarlm_build_image_parse_requirements "$@"
      shift $#
      ;;

    depot-build)
      action="depot-build"
      shift
      scalarlm_depot_build_parse_requirements "$@"
      shift $#
      ;;

    up)
      action="up"
      shift
      scalarlm_up_parse_requirements "$@"
      shift $#
      ;;

    test)
      action="test"
      shift
      scalarlm_test_parse_requirements "$@"
      shift $#
      ;;

    llm)
      action="llm"
      shift
      scalarlm_llm_parse_requirements "$@"
      shift $#
      ;;

    pypi)
      action="pypi"
      shift
      scalarlm_pypi_parse_requirements "$@"
      shift $#
      ;;

    benchmark)
      action="benchmark"
      shift
      scalarlm_benchmark_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      scalarlm_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
scalarlm_build_image_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        scalarlm_build_image_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build-image"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['target']+x} ]]; then
          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['target']:-} ]] || args['target']="cpu"

  # :command.whitelist_filter
  if [[ -n ${args['target']:-} ]] && [[ ! ${args['target']:-} =~ ^(cpu|nvidia|arm|amd)$ ]]; then
    printf "%s\n" "target must be one of: cpu, nvidia, arm, amd" >&2
    exit 1
  fi

}

# :command.parse_requirements
scalarlm_depot_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        scalarlm_depot_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="depot-build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['target']+x} ]]; then
          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['target']:-} ]] || args['target']="cpu"

  # :command.whitelist_filter
  if [[ -n ${args['target']:-} ]] && [[ ! ${args['target']:-} =~ ^(cpu|nvidia|arm|amd)$ ]]; then
    printf "%s\n" "target must be one of: cpu, nvidia, arm, amd" >&2
    exit 1
  fi

}

# :command.parse_requirements
scalarlm_up_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        scalarlm_up_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="up"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['target']+x} ]]; then
          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['target']:-} ]] || args['target']="cpu"

  # :command.whitelist_filter
  if [[ -n ${args['target']:-} ]] && [[ ! ${args['target']:-} =~ ^(cpu|nvidia|amd)$ ]]; then
    printf "%s\n" "target must be one of: cpu, nvidia, amd" >&2
    exit 1
  fi

}

# :command.parse_requirements
scalarlm_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        scalarlm_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --coverage-path)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--coverage-path']="$2"
          shift
          shift
        else
          printf "%s\n" "--coverage-path requires an argument: --coverage-path COVERAGE-PATH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --verbose)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--verbose']="$2"
          shift
          shift
        else
          printf "%s\n" "--verbose requires an argument: --verbose VERBOSE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --workers)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--workers']="$2"
          shift
          shift
        else
          printf "%s\n" "--workers requires an argument: --workers WORKERS" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['test-path']+x} ]]; then
          args['test-path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['test-path']:-} ]] || args['test-path']="test/infra/*"
  [[ -n ${args['--coverage-path']:-} ]] || args['--coverage-path']="/tmp/cray/coverage"
  [[ -n ${args['--verbose']:-} ]] || args['--verbose']="no"
  [[ -n ${args['--workers']:-} ]] || args['--workers']="auto"

  # :command.whitelist_filter
  if [[ ${args['--verbose']:-} ]] && [[ ! ${args['--verbose']:-} =~ ^(yes|no)$ ]]; then
    printf "%s\n" "--verbose must be one of: yes, no" >&2
    exit 1
  fi

}

# :command.parse_requirements
scalarlm_llm_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        scalarlm_llm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    plot)
      action="plot"
      shift
      scalarlm_llm_plot_parse_requirements "$@"
      shift $#
      ;;

    logs)
      action="logs"
      shift
      scalarlm_llm_logs_parse_requirements "$@"
      shift $#
      ;;

    ls)
      action="ls"
      shift
      scalarlm_llm_ls_parse_requirements "$@"
      shift $#
      ;;

    squeue)
      action="squeue"
      shift
      scalarlm_llm_squeue_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      scalarlm_llm_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
scalarlm_llm_plot_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        scalarlm_llm_plot_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="llm plot"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['model']+x} ]]; then
          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
scalarlm_llm_logs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        scalarlm_llm_logs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="llm logs"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tail | -t)

        # :flag.case_no_arg
        args['--tail']=1
        shift
        ;;

      # :flag.case
      --follow | -f)

        # :flag.case_no_arg
        args['--follow']=1
        shift
        ;;

      # :flag.case
      --lines | -l)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--lines']="$2"
          shift
          shift
        else
          printf "%s\n" "--lines requires an argument: --lines, -l LINES" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['model']+x} ]]; then
          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--lines']:-} ]] || args['--lines']="100"

}

# :command.parse_requirements
scalarlm_llm_ls_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        scalarlm_llm_ls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="llm ls"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
scalarlm_llm_squeue_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        scalarlm_llm_squeue_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="llm squeue"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
scalarlm_pypi_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        scalarlm_pypi_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="pypi"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
scalarlm_benchmark_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        scalarlm_benchmark_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="benchmark"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['target']+x} ]]; then
          args['target']=$1
          shift
        # :argument.case
        elif [[ -z ${args['visible-gpus']+x} ]]; then
          args['visible-gpus']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['target']:-} ]] || args['target']="cpu"
  [[ -n ${args['visible-gpus']:-} ]] || args['visible-gpus']="0"

  # :command.whitelist_filter
  if [[ -n ${args['target']:-} ]] && [[ ! ${args['target']:-} =~ ^(cpu|nvidia|arm|amd)$ ]]; then
    printf "%s\n" "target must be one of: cpu, nvidia, arm, amd" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="0.5.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "build-image") scalarlm_build_image_command ;;
    "depot-build") scalarlm_depot_build_command ;;
    "up") scalarlm_up_command ;;
    "test") scalarlm_test_command ;;
    "llm") scalarlm_llm_command ;;
    "llm plot") scalarlm_llm_plot_command ;;
    "llm logs") scalarlm_llm_logs_command ;;
    "llm ls") scalarlm_llm_ls_command ;;
    "llm squeue") scalarlm_llm_squeue_command ;;
    "pypi") scalarlm_pypi_command ;;
    "benchmark") scalarlm_benchmark_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
